[Источник текста](https://ru.stackoverflow.com/questions/361807/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-wildcard-%D0%B2-generics-java)

Чтобы понять мнемонику PECS (provider - extends, consumer - super), рассмотрим в качестве конкретного примера статический метод из стандартного класса Collections:
```
public static <T> void copy(List<? super T> dest, List<? extends T> src)
```
Этот метод копирует список типа Т в другой список. Он использует сразу оба вида ограничений: сверху для целевого списка и снизу для источника.

Начнем с источника. Источником могут быть любые дочерние от T типы. Это логично, нас не интересует, что именно мы перекладываем, нужно, чтобы оно хотя бы сводилось к T. src является для нас поставщиком (producer) объектов, и его тип мы позволяем расширять (extends). Это первые 2 буквы из мнемоники PECS.

Теперь перейдем к целевому списку. В дальнейшем этим списком кто-то будет пользоваться и, возможно, как-то его обрабатывать, и это накладывает определенные ограничения. Проще посмотреть это на примере.

Предположим, что у нас есть класс Питомцев (являющийся подклассом Животных) и дочерние классы Собачонок и Котиков:

```
class Animal { void feed() {} }
class Pet extends Animal { void call() {} }
class Cat extends Pet{ void meow() {} }
class Doge extends Pet{ void bark() {} }
```

Теперь мы хотим скопировать из списка Питомцев в список Питомцев и позвать их.

```
List<Pet> src = ...;
List<Pet> dest = new ArrayList<Pet>();    
Collections.copy(dest, src);
for(Pet p: dest) p.call();
```
Пока все ок. А что если бы в src были явно Котики (унаследованные от Питомцев)?

```
List<Cat> src = ...;
List<Pet> dest = new ArrayList<Pet>();    
Collections.copy(dest, src);
for(Pet p: dest) p.call();
```
Без проблем, Котики откликаются на зов. При копировании в dest мы "потеряем" знание о том, что это были именно Котики, но по крайней мере они остаются Питомцами и их все еще можно позвать.

Достаточно очевидно, что мы не можем скопировать Котиков в коллекцию Собачонок и заставить их всех лаять:

```
List<Cat> src = ...;
List<Doge> dest = new ArrayList<Doge>();    
Collections.copy(dest, src);
for(Doge doge: dest) doge.bark();
```
Очевидный нонсенс, Котиков нельзя просто грубо назвать Собачонками, система типов не позволит так сделать, поэтому мы не смогли бы расширить тип первого параметра в сигнатуре метода copy:

```
public static <T> void copy(List<? extends T> dest, List<? extends T> src); // так нельзя копировать!
```

Но что же насчет super? Пусть наш код продолжит копировать Питомцев, а где-то в другом место другой код кормит любых Животных, и не только домашних.

```
List<Animal> dest = new ArrayList<Animal>();   
.....
List<Cat> src = ...;
Collections.<Pet>copy(dest, src);
....
for(Animal a: dest) a.feed();
```
Все Животные накормлены. Заметим, что целевой список является коллекцией Животных, являющихся родительским классом для Питомцев. Общая концепция такова, что код, который использует в дальнейшем список dest, не может в своих предположениях о его элементах опускаться ниже типа T, но может сколь угодно абстрагироваться к родительским типам. Список dest является потребителем (consumer), т.к. мы наполняем его и знаем, только, что его элементы совместимы с T, а значит сами являются T или лежат выше по иерархии (super). Это последние две буквы в мнемонике PECS.